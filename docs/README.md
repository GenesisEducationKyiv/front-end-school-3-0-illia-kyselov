## ADR: Improving iMusicManager typing and performance optimisation

Date: 2025-05-29
Status: Proposed

Summary: It is proposed to implement a set of changes to improve typing and performance of iMusicManager: use Zod for schemas and data validation, apply neverthrow for safe error handling, apply custom type guards and assert functions (invariant) for type narrowing, and get rid of `any`/`as` casts. At the same time, optimise the interface through `React.memo`/`useMemo`/`useCallback`, lazy loading and dynamic component imports, and limit excessive animations. This will provide a significant improvement in type safety and application performance.

# Context

The project is implemented in TypeScript with clearly described interfaces for APIs, but the code uses numerous unsafe casts that bypass type checking. The absence of runtime data validation (both at the level of API responses and in input forms) allows incorrect or incomplete data to enter the system and cause runtime errors. Traditional error handling through try/catch often leads to a scattering of logic and the risk of missing exceptions. In addition, the interface suffers from performance: many components (modal windows, grids, lists) are loaded at once without code splitting and memoisation, and active animations (Framer Motion) with a large number of elements slow down the UI response.

# Decision.

* Use the Zod library to define data schemas and validate API responses and form fields. Zod integrates with TypeScript and provides generated types and runtime validation. In particular, in React, you can use Zod together with \[react-hook-form] to combine form data validation and type safety. This approach ensures that data anomalies are detected during the validation phase, preventing many potential errors.
** **Error handling with neverthrow:** Instead of `try/catch`, use the neverthrow library, which introduces the concept of *Result* (types `Ok`/`Err`) for error handling. neverthrow contains a `Result` type representing either success (`Ok`) or error (`Err`), and provides a `ResultAsync` for asynchronous operations. This allows you to return explicit results of operations and ensure that error cases are not missed at the type level. In the code, errors are handled functionally (`andThen`, `match`, etc.) without careless exception throwing, which will make the data flow more predictable and transparent. As noted, relying on exceptions is similar to using `any` in a type system, so abandoning `try/catch` in favour of neverthrow improves the reliability of error handling.
** **Type guards and invariants:** Instead of unsafe casts, use your own type guard functions and assert functions. Such functions check whether a value belongs to a certain type and, if not, throw an error. This narrows down the types of variables at the compile time without manual `as'. This approach improves the reliability of the code: in particular, type guards make the code cleaner and more stable, and in most cases can completely replace direct `as` casts. The `invariant(condition, message)` functions can be used to check critical assumptions in the runtime: if the `condition` condition is false, they will throw a special error with a message, which will help you to record incorrect programme states.
* Remove `any` and minimise `as`:** Instead, interfaces and data types should be clearly defined or validated (e.g. via Zod). In the case of a typed data model, error patterns that previously went unnoticed will be detected at compile time.

* **Memoising React components:** Optimise rendering with `React.memo‘, `useMemo’, and `useCallback'. Wrap in `React.memo` those components that always render the same way at constant props: a memoised component will not be re-rendered if its props do not change. For expensive computations, use `useMemo‘ to cache results between renders, and for functional props, use `useCallback’ to stabilise their identity between calls. This will reduce the number of unnecessary renders and the load on the framework.
* Lazy loading:** Delay loading of heavy or minor components until they are first used. In particular, modal windows (TrackModal, UploadModal, ConfirmDialog), dialogs, and large lists/grid imports should be dynamically loaded using `React.lazy` or `import()`. This approach implements code splitting and will reduce the initial size of the JS package, because part of the code is loaded only when needed. This will speed up the initial loading of the page, as unnecessary functionality will be loaded later.

# Consequences

Making these decisions will lead to a significant increase in code reliability. The use of Zod and strict types will ensure that incorrect data is detected in advance, reducing the likelihood of runtime errors. Validation of API responses on the client and strict typing will increase data consistency: errors such as incorrect fields will be detected at the compile time. Removing `any` and minimising casts will improve the readability and maintainability of the code, as developers will no longer be able to ignore an unknown data type. On the other hand, it should be borne in mind that the introduction of Zod and new types will require initial time spent on rewriting existing modules and writing schemas. However, these costs are justified by a significant reduction in the number of errors and improved development experience.

Error handling through neverthrow will make the system more predictable: instead of hidden exceptions, functions will return explicit results (`Ok`/`Err`), and error handling will become part of a typical system. This will make it harder to miss accidental errors and simplify tracing, since all the logic will work with the result, not with unhandled exceptions. The downside may be additional complexity in the code: developers will have to get used to the new pattern (`andThen`/`match` instead of the usual `try/catch`), but this is compensated by clearer error control.

Performance optimisations will improve the performance of the interface. `React.memo` and memoisation hooks will reduce unnecessary renders, as the component will not be re-rendered without changing props. Lazy loading and code splitting will reduce the initial code size, which will speed up the first page render. At the same time, you should make sure that this does not lead to an excessive number of network requests (when splitting code) and provide fallback UIs when loading components. In general, these changes are expected to give a noticeable boost in performance and responsiveness, especially on weak devices or slow connections.